#include <stdio.h>

/**
 * 知识点：位运算 (Bitwise Operations) - 精确操控每一个比特 (Bit)
 * 1. 基本逻辑：
 *    - & (与)：全 1 为 1 (屏蔽某些位)
 *    - | (或)：有 1 为 1 (设置某些位)
 *    - ~ (取反)：1 变 0，0 变 1
 *    - ^ (异或)：不同为 1，相同为 0 (翻转某些位)
 * 2. 移位运算：
 *    - << (左移)：低位补 0，相当于乘 2。
 *    - >> (右移)：高位补符号位，相当于除 2。
 * 3. 应用：硬件寄存器控制、标志位压缩存储、权限控制。
 */

// 辅助观察二进制位的工具函数
void explain_bits(const char *title, unsigned char n) {
    printf("%-20s: 0x%02X (二进制: ", title, n);
    for (int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i == 4) printf(" "); // 每 4 位加个空格方便看
    }
    printf(")\n");
}

int main() {
    printf("==== 1. 位运算的“逻辑面孔” ====\n");
    
    unsigned char flag = 0x05; // 二进制: 0000 0101 (第 0 位和第 2 位是 1)
    explain_bits("[初始状态]", flag);

    // [技巧] 置位 (Set Bit)：使用 | (或)
    // 目标：将第 1 位置为 1
    flag |= 0x02; // 0x02 是 0000 0010
    explain_bits("[置位] | 0x02", flag);

    // [技巧] 清位 (Clear Bit)：使用 & 和 ~
    // 目标：将第 0 位强行抹除为 0
    flag &= ~0x01; // ~0x01 将 0000 0001 变成 1111 1110
    explain_bits("[清位] & ~0x01", flag);

    // [技巧] 翻转位 (Toggle)：使用 ^ (异或)
    // 目标：第 2 位原来是 1 就变 0，原来是 0 就变 1
    flag ^= 0x04; // 0x04 是 0000 0100
    explain_bits("[翻转] ^ 0x04", flag);

    printf("\n==== 2. 移位的魔法：数学视角 ====\n");
    unsigned char num = 5; // 0000 0101
    explain_bits("[初始数值]", num);
    
    // 左移 1 位意味着所有的 1 向左跳，低位补 0
    explain_bits("左移 [num << 1]", num << 1); // 结果是 10
    printf("  - 结论：左移 N 位相当于乘以 2 的 N 次方。\n");

    // 右移 1 位意味着所有的 1 向右跳
    explain_bits("右移 [num >> 1]", num >> 1); // 结果是 2
    printf("  - 结论：右移 N 位相当于除以 2 的 N 次方 (向下取整)。\n");

    printf("\n==== 3. 位运算中的常见陷阱 ====\n");
    
    // 优先级陷阱
    printf("[坑点] 优先级：关系运算 (==) 远高于位运算 (&)。\n");
    printf("  - if (flag & 1 == 0) 会被编译器看成 if (flag & (1 == 0))。\n");
    printf("  - [建议] 永远给位运算外层加上括号：if ((flag & 1) == 0)。\n");

    // 逻辑 vs 位
    printf("\n[坑点] 含义完全不同：\n");
    printf("  - && (逻辑与) 结果只有 0 或 1。\n");
    printf("  - &  (按位与) 会对每一个二进制位进行计算。\n");
    printf("  - 严禁混用！(比如用 & 代替 && 会导致难以排查的逻辑错误)。\n");

    return 0;
}

/*
 * 【位运算实战经验】
 * 1. 嵌入式开发中，我们常用位运算来控制 LED 或者传感器寄存器。
 * 2. 位运算的速度由于接近 CPU 调用，通常比普通的算术运算要快极多。
 * 3. 如果处理可能带有符号的负数，右移运算的行为 (>> ) 在不同编译器上可能不同，建议仅对 unsigned 类型使用位移。
 */
