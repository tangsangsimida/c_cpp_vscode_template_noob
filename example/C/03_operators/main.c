#include <stdio.h>

/**
 * 知识点：运算符与表达式 (Operators & Expressions)
 * 1. 算术运算符：+, -, *, /, %, ++, --
 * 2. 关系与逻辑运算符：>, <, ==, !=, &&, ||, !
 * 3. 位运算符：&, |, ^, ~, <<, >>
 * 4. 三元运算符：? :
 * 5. 常见坑点：赋值 vs 比较、优先级混淆、短路逻辑、自增顺序
 */

int main() {
    printf("==== 1. 算术与自增陷阱 ====\n");
    int a = 10, b = 3;
    printf("[知识点] 整数除法: 10 / 3 = %d (丢弃小数部分)\n", a / b);
    printf("[知识点] 取模运算: 10 %% 3 = %d\n", a % b);

    int i = 5;
    printf("[坑点] 后置自增 i++: 先返回值 %d，后 i 变为 6\n", i++);
    printf("[知识点] 前置自增 ++i: 先 i 变为 7，后返回值 %d\n", ++i);

    printf("\n==== 2. 逻辑与比较“夺命坑” ====\n");
    
    // 坑点 1：赋值 vs 等于
    int x = 0;
    printf("[坑点] if (x = 0) 会把 0 赋给变量，整个表达式结果为 0 (假)，导致 if 分支永远不进。\n");
    if ((x = 5)) { // 这里的 = 是赋值，结果为 5 (真)
        printf("  - 警告：执行了赋值 x = 5，且逻辑判断被视为“真”。当前 x = %d\n", x);
    }

    // 坑点 2：短路逻辑 (Short-circuit)
    int count = 0;
    printf("[知识点] 短路逻辑：(0 && ++count) 既然左边已经为假，右边 ++count 不会被执行。\n");
    if (0 && ++count) {} 
    printf("  - count 依然是 %d (没有被自增)\n", count);

    printf("\n==== 3. 优先级之王：位运算 vs 比较 ====\n");
    int flag = 0x01; // 二进制 0001
    printf("[坑点] 优先级：== 优先级高于位运算 &。\n");
    printf("  - 错误写法: flag & 0x01 == 1 实际等于 flag & (0x01 == 1) -> 1\n");
    printf("  - 正确写法: (flag & 0x01) == 1\n");
    if ((flag & 0x01) == 1) {
        printf("  - [执行] 已通过 (flag & 0x01) 正确检测到第 0 位为 1\n");
    }

    printf("\n==== 4. 三元与逗号表达式 ====\n");
    int score = 85;
    const char* result = (score >= 60) ? "及格" : "挂科";
    printf("[知识点] 三元运算 (?:) 是 if-else 的精简版: %s\n", result);

    int comma_val = (1, 2, 3);
    printf("[知识点] 逗号表达式 (1, 2, 3) 的值是最后一个元素: %d\n", comma_val);

    return 0;
}

/*
 * 应用场景：
 * 1. 控制逻辑：利用 && 和 || 进行条件组合。
 * 2. 硬件控制：利用位运算 (&, |, ~) 精确操作 CPU 寄存器的某一位。
 * 3. 性能优化：在某些循环中使用位移 (<<) 代替乘法 (*)。
 */
