#include <stdio.h>

/**
 * 知识点：预处理指令 (Preprocessor)
 * 1. 预处理器的角色：在正式编译之前，对代码进行“寻找和替换”。
 * 2. #define 宏：不仅仅是常量，还可以是“简易函数”。
 * 3. 陷阱：宏只是简单的文本替换，不带任何数学逻辑，必须靠括号保命。
 * 4. 条件编译：让同一套代码在不同的环境（如 Windows 和 Linux）下运行。
 * 5. 内置宏：编译器自带的“小间谍”，能告诉你当前的行号、文件名。
 */

// --- 1. [重点] 宏定义的真面目：文本替换 ---
// SQUARE(x) 看起来像函数，但其实它只是在源代码中寻找 SQUARE(x) 并把其换成 x * x
#define SQUARE(x)      x * x 
// 正确做法：给参数和整体都加括号，防止被周围的运算符“带节奏”
#define SAFE_SQUARE(x) ((x) * (x))

// --- 2. 条件编译：程序的“开关” ---
#define VERSION_BETA // 如果注释掉这一行，逻辑就会变

// --- 3. [进阶] 多行宏定义 ---
// 为了保证在 if-else 等结构中安全运行，多行宏通常包裹在 do { ... } while(0) 中
#define PRINT_VALUES(a, b) do { \
    printf("    Value A: %d\n", a); \
    printf("    Value B: %d\n", b); \
} while(0)

int main() {
    printf("==== 1. 宏定义的“偷梁换柱”实验 ====\n");
    
    // 逻辑：1+2=3，3的平方应该是 9
    int num = 1 + 2; 
    
    printf("[坑点] SQUARE(1+2) 的结果是: %d\n", SQUARE(num)); 
    printf("  - 为什么是 5 而不是 9？\n");
    printf("  - 因为预处理器把它换成了: 1 + 2 * 1 + 2 = 1 + 2 + 2 = 5\n");
    
    printf("[结论] 使用宏处理数学运算时，必须写成: ((x) * (x))\n");
    printf("  - SAFE_SQUARE(1+2) 的结果是: %d (正确！)\n", SAFE_SQUARE(num));

    printf("\n==== 2. 条件编译：代码的“遥控器” ====\n");
#ifdef VERSION_BETA
    printf("[提示] 当前处于【测试版】，我们会打印额外的调试信息。\n");
#else
    printf("[提示] 当前处于【正式版】，代码运行更高效洁净。\n");
#endif

    printf("\n==== 3. 编译器的小间谍 (内置宏) ====\n");
    printf("[知识点] 我不需要定义：\n");
    printf("  - 当前文件名 (__FILE__): %s\n", __FILE__);
    printf("  - 当前所在行 (__LINE__): %d\n", __LINE__);
    printf("  - 编译日期   (__DATE__): %s\n", __DATE__);

    printf("\n==== 4. 多行宏的调用演示 ====\n");
    PRINT_VALUES(10, 20);

    return 0;
}

/*
 * 【预处理器使用总结】
 * 1. 宏定义不是函数！它不检查类型，只是盲目地寻找并将文字替换掉。
 * 2. 宏定义末尾千万不要加分号 ';' (除非你非常确定你在做什么)，否则替换后多出来的分号会毁掉你的 if-else。
 * 3. 宏定义的精髓在于“跨平台”和“极速”，因为它没有函数调用的额外开销。
 */
